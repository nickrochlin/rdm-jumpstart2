---
title: "Base R & Tidyverse"
pagetitle: "Base R & Tidyverse"
output:
  html_document:
    code_folding: show # allows toggling of showing and hiding code. Remove if not using code.
    code_download: true # allows the user to download the source .Rmd file. Remove if not using code.
    includes:
      after_body: footer.html # include a custom footer.
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
---

## Base R vs Tidyverse

You'll recall fron day 2 that base R is the 'stock' install of R. Base R is generally designed to be backwards compatible. That is, as new versions are released, they try not to deprecate old code, and as such, the hope is that code written under an earlier version of R will still run under the newer version of R -- if you only ever write in base R, you stand a better chance of your code not breaking in future or on a different machine.

However, base R is a hodge podge, so to speak, that has been developped over time. As a result, there is a serious lack of consistency across the implementation of its base functions. This can make it non-intuitive, difficult to understand, difficult to employ, and often violate the principles of literate programming.

On the other hand, Tidyverse is meant to be fast, intuitive, and standardized. Function names describe what they do, function arguments follow known patterns, etc. There is a very specific design philosophy to all the packages in the Tidyverse. This makes it great for interactive programming and iterative development. But, it ostensibly stands a higher chance than base R that future versions of the packages will not be compatible with older versions and that it will likely break at some point in the future with updates.

Given this, consider what you need. In a large, complex environment, one might start with a scripting language prone to deprecation with updates to ideate, but implement in a stable low level language, and then optimize specific parts in machine code. Some projects may only warrant computational reproducibility for the next five years, and so this level of refinement and optimization is not necessary.