---
title: "Day 3 - Part 2"
pagetitle: "Subsetting the data"
output:
  html_document:
    code_folding: show # allows toggling of showing and hiding code. Remove if not using code.
    code_download: true # allows the user to download the source .Rmd file. Remove if not using code.
    includes:
      after_body: footer.html # include a custom footer.
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
---
# Introduction

Subsetting data is an essential step in data analysis that involves extracting a portion of your dataset based on specific conditions. Being able to filter rows and select columns allows you to focus on relevant parts of your data.

Let's return to the time usage dataset. In this section, suppose you're interested in understanding patterns—such as how work-life balance varies, how educational background shapes time perception, or how demographics influence social time. To answer these questions, you don't need every single row or column, as working with the data in its original format would be unnecessarily complex. Instead, you need to "get inside" your data by subsetting: filtering the rows and selecting the columns that matter.

In this short tutorial, we will learn:

- Why subsetting is crucial and what subsetting means
- How to perform subsetting using conditional operators the dplyr functions `filter()` and `select()`

We will explore our dataset through three guiding questions:

1. How do people who feel rushed spend their time differently from those who don’t?
<!-- 2. Do people with different education levels feel differently about time? How does this relate to how much time they spend working or studying? -->
<!-- 3. How does age and marital status affect how much time people spend alone versus with family or friends? -->

First, let's take a look at our data to see what we ended up with from the previous steps.

## Load and Understand Dataset 

To begin, load your `timeuse_day3_1.Rdata` file from the previous session. You can load the file into R using the `load()` function.

```{R}

library(dplyr)

# 
file_path <- "data/timeuse_day3_1.Rdata"

# Load the .Rdata file
load(file_path)

# Check what objects were loaded
ls()

# View the first few rows of the dataset
head(data)
```
As you can see, there are 30 columns in the dataset, which is a lot to work with. For now, we can focus on the following key columns:
   - `id`: Record identification
   - `ageGrp`: Age group of respondent (groups of 10)
   - `sex`: Sex of respondent
   - `maritalStat`: Marital status of the respondent
   - `province`: Province of residence
   - `popCenter`: Population centre indicator
   - `eduLevel`: Educational attainment (highest degree)
   - `feelRushed`: General time use – Feel rushed
   - `extraTime`: General time use – Extra time
   - `durSleep`: Duration – Sleeping, resting, relaxing, sick in bed
   - `durWork`: Duration – Paid work
   - `timeWorkaholic`: Perceptions of time – Workaholic
   - `timeWantAlone`: Perceptions of time – Would like more time alone

hese columns provide information on demographics, time usage, and time perceptions. We can use them to explore patterns in work–life balance, education, and social time.

## Conditional Filtering with Boolean Operators using dplyr

dplyr is a powerful package that lets you extract and transform data with a clear, readable syntax. In dplyr, you use functions like `filter()`, `select()`, and `mutate()` to work with your data. Boolean operators (`==`, `<`, `>`, `<=`, `>=`, and `!=`) are used within these functions to test conditions, and you can combine conditions with `&` (and) or `|` (or).

### **Comparison Operators**

Comparison operators allow you to check conditions within your dataset. These return `TRUE` or `FALSE` based on whether the condition is met.

| Operator | Meaning                  | Example  | Result |
|----------|--------------------------|----------|--------|
| `==`     | Equal to                 | `5 == 5` | `TRUE` |
| `!=`     | Not equal to             | `5 != 3` | `TRUE` |
| `<`      | Less than                | `3 < 5`  | `TRUE` |
| `>`      | Greater than             | `5 > 3`  | `TRUE` |
| `<=`     | Less than or equal to    | `3 <= 3` | `TRUE` |
| `>=`     | Greater than or equal to | `5 >= 3` | `TRUE` |

### **Logical Operators**

Logical operators allow you to filter data based on multiple conditions.

| Operator | Meaning                                        | Example               | Result |
|----------|------------------------------------------------|-----------------------|--------|
| `&`      | Logical AND (Both conditions must be TRUE)     | `(5 > 3) & (4 < 6)`    | `TRUE` |
| `|`      | Logical OR (At least one condition must be TRUE)| `(5 > 3) | (4 > 6)`     | `TRUE` |
| `!`      | Logical NOT (Reverses TRUE/FALSE)               | `!(5 > 3)`            | `FALSE` |

Let’s try using these logical operators to filter the rows in the following example.

### Work–Life Balance

We want to understand whether feeling rushed might relate to how much time is spent on work, sleep, or alone time. Therefore, the columns of interest are `feelRushed`, `durSleep`, `durWork`, and `durAlone`. First, let's explore the values in these columns using dplyr.

```{r}
library(dplyr)

# Explore the unique values for each column
data %>% 
  distinct(feelRushed) %>% 
  print()

data %>% 
  distinct(durSleep) %>% 
  print()

data %>% 
  distinct(durWork) %>% 
  print()

```

It appears that all three columns contain numeric values. However, as you look at the metadata file, you'll see that only `durWork` and `durSleep` have numeric values that represent real quantities (hours of work or sleep in a month). In contrast, the values in the `feelRushed` column have a different meaning.

| Code | Value        |
|------|-------------|
| 1    | daily       |
| 2    | few Times a Week |
| 3    | once a Week    |
| 4    | once a Month   |
| 5    | less a Month   |
| 6    | never       |
| 96   | valid Skip   |
| 97   | dont Know    |
| 98   | refusal     |
| 99   | not Stated   |

<!-- handle those with na values here  -->

# Filtering Rows with dplyr
For this analysis, we will consider respondents who report feeling rushed as those whose frequency is at least once a week, and those with less than once a week as not feeling rushed.

## Extracting Respondents Who Do or Do not Feel Rushed Daily
First, let’s extract only the respondents who report feeling rushed daily. Looking at the table, the value corresponding to feeling rushed daily is number 1. We can filter for these respondents using filter().

```{r}
daily_rushed <- data %>% 
  filter(feelRushed == 1)

head(daily_rushed)
```

The condition `feelRushed == 1` creates a logical vector that is `TRUE` for rows where the value equals 1 (corresponding to “daily”). Using `filter()`, we subset the data to keep only those rows where the condition is met. 

## Using Comparison and Logical Operators

Not only can you use the `==` operator to test for equality, but you can also use operators such as `<`, `>`, `<=`, `>=`, and `!=` to compare values. For example, you might filter rows where a numeric variable exceeds a certain threshold, is below a limit, or is not equal to a specified value. Let's use an example from the `duration` sleep columns

For instance, if we want to filter rows for the `durSleep` column to capture any instances with sleep duration less than `600`, we can write:

```{r}
short_sleep <- data %>% 
  filter(durSleep < 600)

head(short_sleep)
```

Alternatively, we can filter rows where `durSleep` is between `600` and `1000`. To do this, we chain two conditions using the `&` operator:

```{r}
sleep_range <- data %>% 
  filter(durSleep >= 600 & durSleep <= 1000)

head(sleep_range)
```

In this example:
- The condition `data$durSleep >= 600` checks for rows where sleep duration is at least `600`.
- The condition `data$durSleep <= 1000` checks for rows where sleep duration is at most `1000`.
- The `&` operator combines these conditions, ensuring that only rows satisfying both conditions are returned.

By using these boolean operators, you can chain multiple conditions together. Not only can you use the `&` operator for “and” conditions, but you can also use the `|` operator to specify “or” conditions.


## Complex Filtering with dyplyr

Now, let's back into or main task again. 

Now, let’s perform a more complex filtering. Suppose we want to capture respondents who feel rushed frequently—that is, those whose `feelRushed` value is either `1`, `2`, or `3`—and those who do not feel rushed frequently, meaning those whose `feelRushed` value is either `4`, `5`, or `6`.

There are multiple ways to filter rows that meet one of these conditions. The first method uses a range comparison with `<=` to filter the rows.

```{r}
# Filter rows for respondents who feel ru shed: those with feelRushed <= 3
rushed <- data %>% 
  filter(feelRushed <= 3)

# For not rushed, we filter rows where feelRushed is >= 3 and <= 6
not_rushed <- data %>% 
  filter(feelRushed >= 3 & feelRushed <= 6)

# View the first few rows of each subset
head(rushed)
head(not_rushed)

# Calculate the number of rows in each subset
all_rows <- nrow(data)
rushed_rows <- nrow(rushed)
not_rushed_rows <- nrow(not_rushed)

print(paste("The number of rows in data is:",all_rows))
print(paste("The number of rows in rushed is:", rushed_rows))

```
This approach selects rows where `feelRushed` is less than or equal to `3` (i.e., values `1` or `2`) to indicate respondents who feel rushed, while rows where `feelRushed` is greater than or equal to `3` and less than or equal to `6` are considered not rushed. Here, you can see that we use the & operator to chain two conditions for the not rushed group. It isn’t necessary that the upper bound be `6`, but we use it here to demonstrate how to chain two boolean operations.

Furthermore, the `nrow` function calculates the number of rows in the data frame. For example, if the original data frame has `12,689` rows, after filtering, the rushed data frame might contain only `2,537` rows.

The second method involves chaining three conditions using the `|` operator:

```{r}
# Filter rows for respondents who feel rushed (values 1, 2, or 3)
rushed <- data %>% 
  filter(feelRushed == 1 | feelRushed == 2 | feelRushed == 3)
head(rushed)

# Filter rows for respondents who do not feel rushed (values 4, 5, or 6)
not_rushed <- data %>% 
  filter(feelRushed == 4 | feelRushed == 5 | feelRushed == 6)
head(not_rushed)

# Calculate the number of rows in each subset
rushed_rows <- nrow(rushed)
not_rushed_rows <- nrow(not_rushed)

print(paste("The number of rows in rushed is:", rushed_rows))
print(paste("The number of rows in not rushed is:", not_rushed_rows))

```

This method explicitly tests for rows where the `feelRushed` value is either `1`, `2`, or `3`. Although this method is more verbose, it shows how to chain multiple conditions together using the `|` operator for "or" conditions. As you can see, looks at the remain row, it produces the same output as previously

We can also use the `%in` operator. 

```{r}
# Define the levels that indicate feeling rushed and not rushed
rushed_levels <- c(1, 2, 3)
not_rushed_levels <- c(4, 5, 6)

# Filter the data using the %in% operator
rushed <- data %>% 
  filter(feelRushed %in% rushed_levels)

not_rushed <- data %>% 
  filter(feelRushed %in% not_rushed_levels)

# View the first few rows of each subset
head(rushed)
head(not_rushed)

# Calculate the number of rows in each subset
rushed_rows <- nrow(rushed)
not_rushed_rows <- nrow(not_rushed)

print(paste("The number of rows in rushed is:", rushed_rows))
print(paste("The number of rows in not rushed is:", not_rushed_rows))

```

This method explicitly tests for rows where feelRushed is in the set `{1, 2, 3}` for rushed respondents, and in `{4, 5, 6}` for not rushed respondents.

## Selecting Time Allocation Columns

Next, we select only the key time allocation columns: `durWork`, `durSleep`, and `durAlone`. 

<!-- We also want to mark any values larger than 9995 as NA, as these represent invalid or out-of-range values. -->

```{r}
# Select the time allocation columns for each group
rushed_time <- rushed %>% 
  select(durWork, durSleep, durAlone)

not_rushed_time <- not_rushed %>% 
  select(durWork, durSleep, durAlone)

# Replace values greater than 9995 with NA using mutate and across
rushed_time <- rushed_time %>% 
  mutate(across(everything(), ~ ifelse(. > 9995, NA, .)))

not_rushed_time <- not_rushed_time %>% 
  mutate(across(everything(), ~ ifelse(. > 9995, NA, .)))

head(rushed_time)
head(not_rushed_time)
```

## Comparing the Means
  
Finally, we want to compare the means of duration of sleep, work, and alone time for respondents who feel rushed and those who do not feel rushed to see if there is a difference between the two groups.

```{r}
# Calculate the mean values for each variable using summarise and across
mean_rushed <- rushed_time %>% 
  summarise(across(everything(), ~ mean(. , na.rm = TRUE)))

mean_not_rushed <- not_rushed_time %>% 
  summarise(across(everything(), ~ mean(. , na.rm = TRUE)))

# Calculate the differences between the means (rushed - not rushed)
diff_means <- mean_rushed - mean_not_rushed

# Print the results
print("Mean values for respondents who feel rushed:")
print(mean_rushed)
print("Mean values for respondents who do not feel rushed:")
print(mean_not_rushed)
print("Difference between rushed and not rushed (rushed - not rushed):")
print(diff_means)
```
The `colMeans` function calculates the mean of each column in a matrix or data frame. Here, `na.rm = TRUE` tells R to remove (ignore) any rows containing NA values from the calculations, ensuring that the computed means are based solely on available data.

Based on the mean values, respondents who feel rushed tend to spend more time working and less time sleeping and alone compared to those who do not feel rushed. This pattern makes sense.

