---
title: "Computational Reproducibility: Dependencies"
pagetitle: "Computational Reproducibility: Dependencies"
output:
  html_document:
    code_folding: show # allows toggling of showing and hiding code. Remove if not using code.
    code_download: true # allows the user to download the source .Rmd file. Remove if not using code.
    includes:
      after_body: footer.html # include a custom footer.
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
---

:::note
Managing external dependecies is critical to ensuring that you can maintain computational reproducibility when you move your code to a new computer.
:::

## Dependencies

Dependencies are essentially prerequisites -- the things you need to complete a task. For example, so far, we require both R and some of the packages in `tidyverse` to run the code we've written. Dependencies -- and tracking dependencies -- are a significant issue in computationally reproducible research.

Part of good research data management when using a scripting language is finding ways of tracking and documenting dependencies. At it's simplest, this means recording somewhere:

* your operating system and version
* your scripting language and version
* your extra packages or libraries and their versions.

We can break addressing dependencies down into three distinct categories, levels, or environments that need to be addressed:

* Keeping a stable R environment
* Maintaining relationships to external programs
* Keeping a stable operating system environment

## Stable R Environment

We've talked about base R and about extending it with additional packages or libraries. It is very possible that an updated package or an updated version of R could break your code. But this may not happen just on your machine. If you share your R project folder with another person, on another machine, and they have a different version of a package, this could make the script inoperable on their machine. How do we solve this?

It's important to draw a distinction here between a package and a library in R. A package is a set of functions and data. We've seen many of the functions included in the `tidyverse` set of packages. A library is a place where these packages are stored on your computer. You can see where your packages are stored with `.libPaths()`.

```{r}
.libPaths()
```

Note that, by default, these are stored almost in the root of your operating system. So when you move your project folder, you don't also move your additional packages.

The easiest way to handle this, is to use the package `renv`, which keeps copies of your packages in your project folder as well as detailed information about them so that should they need to be re-installed they can be and with the exact same version. Thus, you end up with a stable, reproducible R environment.

#### renv in Action

First we install, load, and initialize `renv` -- this only needs to be done once.

```{r, eval=FALSE}
install.packages("renv")
renv::init()
```

```{r, results='hide', echo=FALSE}
renv::init()
```

:::note
You'll notice that we're using a different way of calling the `init()` function here, first noting the package that it's in `renv` followed by two colons `::`. Similarly to how in day 2 we loaded all of Tidyverse with `library(tidyverse)`, but on day 3 we only loaded one package from the tidyverse, `dplyr`, to trim down how much we were loading into memory, we can also load only specific functions from a package that is installed - we don't call `library()`, we just reference the installed package, and then call the function of interest.
:::

Then we install the libraries that we need for our project locally; even if we've installed these and they are present in `.libPaths()`, we need to reinstall them in our project folder, as `renv` only looks in our project folder for packages. `renv` has an install function that is more verbose than `install.packages()` from base R.

```{r, eval=FALSE}
renv::install("tidyverse")
```

You then load your libraries into you .R or .Rmd files as usual:

```{r, eval=FALSE}
library(tidyverse)
```

Whenever you load a new package, you want to take a `snapshot()`, which tells `renv` to document all the packages you've used in your scripts. In our case, we only need to do this once, since we're only using packages that are contained within `tidyverse`.

```{r}
renv::install("rprojroot", prompt = FALSE)
```

```{r}
renv::snapshot()
```

`renv` adds a couple of new files and folders to your R project. The one that documents your packages is called `renv.lock` and this is where `snapshot()` records its information to.

This is what the `renv.lock` file looks like on the inside:

```{bash echo = FALSE}
cat renv.lock | head -n 20
```

Packages can take up a lot of space, so generally, you don't share your packages, or library folder, with others when you share your R project. Instead, you just share the `renv.lock` file -- the metadata about the packages used -- and the recipient of your folder, after installing the `renv` package, runs `renv::restore()`, which rebuilds your R environment on their machine.

At the end of today, when we upload our data and .Rmd files to OSF, we will now also include the `renv.lock` file.

Read more about the `renv` package at [https://rstudio.github.io/renv/articles/renv.html](https://rstudio.github.io/renv/articles/renv.html)

```{r, results='hide', echo=FALSE}
renv::deactivate(clean = TRUE) # get rid of renv so the website builds properly
```

## External programs

Some R functions and packages are reliant on external programs. The `knittr` package that allows RMarkdown documents to be converted between document types (producing html, pdf, etc documents), and that we will be using later in this workshop, is a good example of this. It can be challenging to ensure that over time and across systems your .Rmd files will in fact output in the way that you expect; this doesn't nullify your code, just the conversion process from .Rmd to .html or .pdf.

Another example is being able to read Excel files into R. And this will lead us into the next consideration of keeping a stable system. There is more than one package available in R to load in Excel files. One, `xlsx` requires that Java, another programming language, be installed on the user's machine. Not everyone has Java, or the right version of Java, installed on their machines. `xlsx` is very prone to breaking code across machines. A second is `readxl` from the tidyverse. `readxl` uses two libraries whose licensing allows for redistribution with someone else's code, so, `readxl` includes and installs these libraries when the `readxl` package is installed. It is very robust when moved across computers and operating systems.

Maintaining relationships to external programs is very challenging. If using packages external to base R and the tidyverse, you should read about these packages first and learn about their dependencies and use them only if they work with your needs as they relate to reproducibility, and, as necessary, maintain robust documentation about them.

* [`xlsx` documentation page](https://cran.r-project.org/web/packages/xlsx/index.html)
* [`readxl` documentation page](https://cran.r-project.org/web/packages/readxl/index.html)

## Keeping a Stable System

We mentioned above that `readxl` uses two external libraries -- this is very common in computer programs -- if one person has solved a problem, i.e. how to read in proprietary Excel files into another application, and is willing to share that solution, no one else needs to solve that same problem. However, for a variety of reasons, not all 'shared' libraries, as these are referred to, can be bundled the way they are in `readxl`. In these instances, these libraries usually sit somewhere else that is globally accessible to any application on your computer. The only way to resolve this kind of dependency is to make a copy of your entire operating system that includes any external programs and your R environment.

This is far more than we cover here, but a popular option is to create a copy of your complete computing environment using an application called Docker.

## Overall Considerations

Consider what your specific needs are before venturing down these routes. A small project written in only base R likely needs only to record the version of R it is using. A project that uses only self contained external R packages only needs `renv`. A project that has external program dependencies may suffice to simply document what these dependencies are and what needs to be installed to resolve them. It is only in large, complex projects, and one's where a risk assessment determines that computational reproducibility is critical, that you would consider resorting to a solution like Docker.

<sup>1</sup> Simmons, J. P., Nelson, L. D., & Simonsohn, U. (2011). False-Positive Psychology: Undisclosed Flexibility in Data Collection and Analysis Allows Presenting Anything as Significant. Psychological Science, 22(11), 1359-1366. [https://doi.org/10.1177/0956797611417632](https://doi.org/10.1177/0956797611417632)