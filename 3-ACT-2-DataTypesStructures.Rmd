---
title: "Day3_DataTypes_DataStructures"
pagetitle: "Data Types and Structures in R"
output:
  html_document:
    code_folding: show # allows toggling of showing and hiding code. Remove if not using code.
    code_download: true # allows the user to download the source .Rmd file. Remove if not using code.
    includes:
      after_body: footer.html # include a custom footer.
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
date: "2025-02-28"
---

```{r, libraries, include = FALSE}
library(kableExtra)
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warnings = FALSE)
```

<h4 style="text-align:center;"><strong>Data in R can be stored as a variety of data types and organized in a variety of data structures. We can also recode data in R depending on our research needs.</strong></h4>

## Data Organization in R

This section covers how data is organized in R and how to clean a dataset. Understanding how your data is organized and being able to adjust that organization to match your research needs is an important part of research data management. For example, you might need your data to be in a certain structure to run certain statistical analyses or you may need to transform variables into versions that are more easily understood. 

![](images/tidyverse-workflow.png)

This section covers five main topics: 

1. What data types exist in R (i.e., is your data composed of numbers, words, or both) 
2. What data structures exist in R (i.e., do you have one long list of elements, a spreadsheet, or something else)
3. Introduction to the `dplyr` package
4. Re-coding existing data into another type of data
5. Dealing with missing values 

Let's get started! 

## Data Types in R
Data can come in many different formats or units. Sometimes we have numbers with decimals, sometimes we have counts of how many times something happened, sometimes we have categories with names. It is important to know what type of data you have, how to figure that out in R, and how to modify the data type if needed. Various functions in R require having certain data types, so this is an important foundational skill for managing data in R. 

#### **Numeric Data**
Numeric data is data made up of numbers. This is what we most commonly think of as data and this data type can have decimals. For example, how many hours people slept on a given day (6, 8.25, 7.5), the percent accuracy that students got on an exam (87.45, 75.92, 98.40), or number of people who attended a data management workshop each day (32, 38, 28). 

#### **Integer Data**
This data type deals with whole numbers (i.e., no decimals) and operates similarly to numeric data types. Some data is stored as "numeric" and "integer" at the same time.

#### **Character/String Data**
Character variables are variables with words or letters. Such as names of people (Erin, Maria, Huy) or places (ON, BC, QC). Character variables usually need to be put in quotation marks in R code, so they are not confused with words that actually denote functions in R. We will create some character variables later in this section. 

#### **Factors**
Factors are how R handles categorical data. Factors can store string or integer data, because sometimes numbers do represent categories (rather than a continuous range of numbers).Factors have leveled data. For example, the variable of education may have the levels of "high school," "bachelors degree," and "masters degree." Factors can be ordered or unordered. 

Factor structure is particularly useful for statistical modeling. Sometimes you might need to change an object into factor structure, so you can use the function `as.factor()` to do so. 

#### **Dates and Times**
Data can also be stored in date and/or time format in R. Our data doesn't contain dates or times, but we want to let you know this is possible. Date data would typically look like "22-05-2025" or "2025-05-22." Times could look like "11:12:34."

#### **Logical Data**
Logical data includes `TRUE` and `FALSE` data. We can also ask R to provide us `TRUE` or `FALSE` response if we ask if a condition is met. 

## Data Structures in R
Data structures are how the data is organized in R. Here are the major data structures in R. There are some additional structures (e.g., matrices and arrays) that are mostly used only when doing statistical modeling. We will skip over these for now and focus on the data structures you will likely encounter in a research data management context. 

#### Vectors
Vectors are simplest data structure. They are essentially a list of elements of the same data type. For example, you could have a numeric vector containing the elements (10, 15, 20, 25) or a character vector containing the elements ("blue", "red", "green"). They are one dimensional, since they are just one long list. A single variable (e.g., a list of ages of all the participants) can be considered a vector. 
#### Data Frames
Data frames are the most common and popular type of data structure used in R. Data frames work essentially like spreadsheets in that they are two dimensional (i.e., have columns and rows) and can store different data types in teh same data frame (i.e., numeric and character). Data frames are made up of vectors of the same length. 

However, data frames do have some constraints. First, the columns and rows must be named. Second, the lists of vectors in the data frame must have equal lengths (i.e., each column needs an identical number of elements/rows). Third, all elements in a single column must be of the same data type (i.e., you can't switch between numbers and names in a single column).

You may see mention of tibbles, which are an updated version of data frames and part of the tidyverse package, and have the same constraints as data frames. They are a bit more user-friendly version of tabular data. 

For this course, our data is in data frame format. 

#### Lists
Lists are an ordered collection of elements. They can contain different data types and they are one dimensional. We don't often have data in list form, but some functions in R will output results into list format, so it is good to be aware of them. Here is an example of a list:

```{r}
list_example <- list("red", 400, "skyblue", "forestgreen", .333)
list_example
```

Because lists are ordered (i.e., each element in the list has a specific spot in the list), you can call for an element based on the order it has been assigned. For example, "skyblue" is third in this example list. 

```{r}
list_example [3]
```

## Introduction to dplyr Library
In order to check and modify data types we suggest using the `dplyr` package, which is part of the Tidyverse. `dplyr` is a powerful R package designed to simplify data manipulation tasks. It provides a set of intuitive functions that make filtering, selecting, and transforming data frames (we will talk about this data structure soon) more readable and efficient. It is the go to package for data set organization. We will use just a few of the functions of this package in this course, but there are many more applications of `dplyr` you can explore. 

Here are some of the most common functions of `dplyr`. We will practice using some of these today with our dataset. 

  - `mutate()`: Useful when you want to create new columns based on values in existing columns in your dataset. For example, you may want to recode numeric data into new categories with character names. 
  
  - `recode()`: Useful for changing data format of variables or re-categorizing certain values in a variable as some other value. For example, maybe you want to label everyone who sleeps less than seven hours a night as "sleep deprived." 

  - `group_by()`: Allows you to view your data based on groups that you define or already exist in your data. For example, you may want to group your data based on whether people live in a city or rural area, or by gender. 
  
  - `summarize()` or `summarise()`: Useful for seeing basic descriptive info about your data. This is particularly helpful when use with the `group_by()` function. For example, you can see if people in cities compared to rural areas feel more rushed on average (i.e., compare means between these two groups). 
  
  - `|>` (pipe operator): Allows you to tell R to apply one function several times. You can read it more or less as "and then" when thinking about what your R code is doing. 
  
  - `filter()`: This function allows you to extract rows that meet specific conditions you include. 
  
  - `select()`: This function lets you choose particular columns based on your specifications. 
  
It is important when using `dplyr` to assign your output to an object if you want to retain the info you've found or created. Remember the `<-` symbol can be used to assign output to a named object. We will practice this today too. 

Together, these functions in `dplyr` enable you to easily explore your data by various subgroups, create new variables, or create a focused subset of your data for further analysis.

Let's explore the data types in our data using the `dplyr` functions!

## Checking Data Types in Our Data

First we load  the `dplyr` package (remember to install it first if you haven't yet). If you have installed the `tidyverse` package, then `dplyr` was also included. However, it is best practice to just load in the libraries you need (i.e., just `dplyr` and not all of the tidyverse packages) to save space. 

We will also load in our data. Yesterday we used the `read_csv` function to read in the csv file, but now we are working with an Rdata file we saved yesterday, so we can use the `load` function. Just to reacquaint ourselves with our data, use the `head` function. 

```{r, message = FALSE}
library(dplyr)
load("data/timeuse_day2.Rdata")
```

```{r, data-isolation, results = FALSE}
head(js_data)
```

```{r, echo = FALSE, message = FALSE, warning=FALSE}
library(kableExtra)
head(js_data)|>
  kbl() |>
  #kable_styling(bootstrap_options = "striped")
kable_paper() %>%
  scroll_box(width = "500px", height = "200px")

```


We can check the data type of variables using the `class()` function and calling for a specific variable from our dataset `data` using the `$` operator, followed by the name of our variable. 

```{r}
class(js_data$province)
```

:::question
Try exploring the data type of a few other variables on your own. 
:::

## Recoding Variables/Data Types
For some variables, we might want to change the data type based on our codebook. For instance, we can see that our "province" variable is in integer format. 
```{r}
class(js_data$province)
```

However, maybe we would prefer to have province acronyms (i.e., character data format) rather than the integer representation of them. We can re-code variables using the dplyr functions `|>` and `mutate()`. The possible integer values for the provicne variable, and what province they represent can be found in the dataset codebook. 

```{r}
js_data <- js_data |> mutate(province_fact = recode_factor(js_data$province, 
                            "10" = "NL", 
                            "11" = "PEI", 
                            "12" = "NS",
                            "13" = "NB", 
                            "24" = "QC", 
                            "35" = "ON", 
                            "46" = "MB", 
                            "47" = "SK", 
                            "48" = "AB", 
                            "59" = "BC"))
```

:::walkthrough
  - This code is telling R to `recode_factor()` the variable "province" from the dataset "js_data" into a new variable called "province_fact" (you could call it anything, but make sure it is a meaningful name). We are using `recode_factor()` instead of just `recode()` to keep the data in factor structure. 

  - The list outlines how each value of the current "province" variable should be recoded for the new "province_fact" variable. 
  
  - The `mutate()` portion tells R to create a new column called "province_fact". 
  
  - Before the `mutate()` function this code tells R to take the "js_data" object (i.e., the dataset) "and then" (i.e., the pipe function) apply the following functions. 
  
  - The pipe function (`|>`) tells R to recode all of these values all at once, rather than having to write out `mutate()` and `recode()` for each one. 
  
  - Lastly, all of this work needs to be assigned back to our dataset "js_data" in order to save it using the `<-` symbol. 
:::

**Note:** We did not assign this work to replace/overwrite the existing "province" variable. In order to have transparent data management and to prevent overwriting the original data in the instance that you make a mistake in your recoding, it is always best practice to keep the original variables in their original format and create new variables based on them as needed. In this way, if you ever need to reference the original data (and you definitely will need to), you still have it available to you. 

Now lets check the data type of this new variable we just created. 
```{r}
class(js_data$province_fact)
```

Most of this dataset is in integer format, because the data does not have decimals, and that is what R defaults to. However, it also stores this data as numeric at the same time. You can see this by checking the "class" of the data and asking if the data "is.numeric".

```{r}
class(js_data$durSleep)
is.numeric(js_data$durSleep)

```
You will see here that you get a logical operator as the output. 

Sometimes you may want to change the data type without recoding all of the data. In this case a useful function is `as.numeric()`. Because this data is already stored as both integer and numeric, this function will not change the data type in this instance, but this can be helpful for other datasets you may work with in the future. Here is an example of how you would use this function. 
```{r, results = 'hide'}
as.numeric(js_data$durSleep)
```

## Missing Data
You may have noticed that there are some cells in the data with "NA." This represents missing data in our dataset. Some missing data is usually present in data. There are many reasons for missing data and many different ways to handle missing data. These choices will depend on the context of specific research, but generally a plan for how to approach missing data should be thought through in advance. 

In this dataset missing data had been notated with various numerical codes (you can see these in the original codebook), but we have recoded the data so that all missing data as been denoted "NA." 

### Missing Data Related Functions
If your data contains NA values, sometimes functions will give error messages due to incomplete data. For example, if you try to get the mean of education level (eduLevel), R will not provide one because it can't calculate a mean when there are missing values. 


```{r}
mean(js_data$eduLevel)
```

Instead, we tell R to ignore those missing values. Including `na.rm = TRUE` to the function will typically tell R that it should complete the function, ignoring missing values. 

```{r}
mean(js_data$eduLevel, na.rm = TRUE)
```

If you want to check if a variable or data frame has missing data, you can use the function `is.na`. 

```{r, results = 'hide'}
is.na(js_data$eduLevel)
```

If you want to know the number of cells with missing data for a given variable you can use the same function, wrapped in the `sum` function. 

```{r}
sum(is.na(js_data$eduLevel))
```

If you want to find instances where there is no missing data you can use `complete.cases()`. 

```{r, results = 'hide'}
complete.cases(js_data)
```

If you want to know the total number of rows (i.e., participants) with no missing data you can take the `complete.cases()` function and wrap it in the `nrow()` function. 

```{r}
sum(complete.cases(js_data))
```

## Your Turn!
### Changing Data Types
::: question
What type of data is the variable for marital status?
:::

```{r class.source = 'fold-hide', results = 'hide'}
class(js_data$maritalStat)
```

:::question
Can you re-code marital status into a character/string variable?
:::

```{r class.source = 'fold-hide', results = 'hide'}
js_data<-js_data |> mutate(maritalStat_fact = recode_factor(js_data$maritalStat, 
                            "1" = "Married", 
                            "2" = "Living common-law", 
                            "3" = "Widowed",
                            "4" = "Separated", 
                            "5" = "Divorced", 
                            "6" = "Single, never married"))

class(js_data$maritalStat_fact)
```

::: question
How about level of education?
:::

```{r class.source = 'fold-hide', results = 'hide'}
js_data <- js_data |> mutate(eduLevel_fact = recode_factor(js_data$eduLevel,
                            "1" = "Less than high school dimploma or its equivalent",
                            "2" = "High school diploma or equivalency",
                            "3" = "Trade certificate or diploma",
                            "4" = "College, CEGEP, or other non-university certificate or dimploma",
                            "5" = "University certificate or dimploma below the bachelor's level",
                            "6" = "Bachelor's degree",
                            "7" = "University certificate, diploma, degree above the BA level"))

class(js_data$eduLevel_fact)
```
### Check Your Knowledge

:::question
What data structure would you use to store the following data?

a) A list of heights of movie characters

b) A list of names of characters from a movie

c) A spreadsheet with both a and b in it

d) The data we have been working with in this workshop
:::

:::question
Is our data in a data frame format? Hint: use the function "is.data.frame()"
:::

